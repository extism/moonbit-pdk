<!DOCTYPE html>
<html>

<head></head>

<body>
  <script>
    const memory = new WebAssembly.Memory({ initial: 1, maximum: 1, shared: false })
    const fakeAlloc = { offset: 0, buffers: {} }
    const alloc = (lengthBigInt) => {
      const offset = fakeAlloc.offset
      const length = Number(lengthBigInt)
      fakeAlloc.buffers[offset] = {
        offset,
        length,
        buffer: new Uint8Array(memory.buffer, offset, length),
      }
      fakeAlloc.offset += length
      return BigInt(offset)
    }
    const allocAndCopy = (str) => {
      const offsetBigInt = alloc(BigInt(str.length))
      const offset = Number(offsetBigInt)
      const b = fakeAlloc.buffers[offset]
      for (let i = 0; i < str.length; i++) { b.buffer[i] = str.charCodeAt(i) }
      return offsetBigInt
    }
    const decodeOffset = (offset) => new TextDecoder().decode(fakeAlloc.buffers[offset].buffer)
    const configs = {
      'vowels': 'aeiouAEIOU',
    }
    const vars = {}  // no vars to start with

    const inputString = 'Once upon a dream'

    const importObject = {
      "extism:host/env": {
        alloc,
        config_get: (offsetBigInt) => {
          const offset = Number(offsetBigInt)
          const key = decodeOffset(offset)
          console.log(`config_get(${offset}) = configs[${key}] = ${configs[key]}`)
          if (!configs[key]) { return BigInt(0) }
          return allocAndCopy(configs[key])
        },
        input_length: () => BigInt(inputString.length),
        input_load_u8: (offsetBigInt) => {
          const offset = Number(offsetBigInt)
          if (offset < inputString.length) { return inputString.charCodeAt(offset) }
          console.error(`input_load_u8: wasm requested offset(${offset}) > inputString.length(${inputString.length})`)
          return 0
        },
        length: (offsetBigInt) => {
          const offset = Number(offsetBigInt)
          const b = fakeAlloc.buffers[offset]
          if (!b) { return BigInt(0) }
          console.log(`length(${offset}) = ${b.length}`)
          return BigInt(b.length)
        },
        load_u8: (offsetBigInt) => {
          const offset = Number(offsetBigInt)
          Object.keys(fakeAlloc.buffers).forEach((key) => {
            const b = fakeAlloc.buffers[key]
            if (offset >= b.offset && offset < b.offset + b.length) {
              const byte = b.buffer[offset - key]
              console.log(`load_u8(${offset}) = ${byte}`)
              return byte
            }
          })
          return 0
        },
        output_set: (offset) => console.log(decodeOffset(offset)),
        store_u8: (offsetBigInt, byte) => {
          const offset = Number(offsetBigInt)
          Object.keys(fakeAlloc.buffers).forEach((key) => {
            const b = fakeAlloc.buffers[key]
            if (offset >= b.offset && offset < b.offset + b.length) {
              b.buffer[offset - key] = byte
              console.log(`store_u8(${offset})=${byte}`)
              if (offset == b.offset + b.length - 1) {
                console.log(`store_u8 completed offset=${key}..${offset}, length=${b.length}: '${decodeOffset(key)}'`)
              }
            }
          })
        },
        var_get: (offsetBigInt) => {
          const offset = Number(offsetBigInt)
          const key = decodeOffset(offset)
          console.log(`var_get(${offset}) = vars[${key}] = ${vars[key]}`)
          if (!vars[key]) { return BigInt(0) }
          return vars[key]  // BigInt
        },
        var_set: (offsetBigInt, bufOffsetBigInt) => {
          const offset = Number(offsetBigInt)
          const key = decodeOffset(offset)
          console.log(`var_set(${offset}, ${bufOffsetBigInt}) = vars[${key}]`)
          vars[key] = bufOffsetBigInt
        },
      },
    }

    WebAssembly.instantiateStreaming(fetch("/target/wasm/release/build/examples/count-vowels/count-vowels.wasm"), importObject).then(
      (obj) => {
        obj.instance.exports._start()
        obj.instance.exports["count_vowels"]()
      }
    )
  </script>
</body>

</html>